import java.lang.* ;import java.util.*;/** Model an enigma machine rotor or reflector.*/public class rotor {   // 5 Available rotors, 2 available reflectors     public static final int ROTOR_I          = 0;    public static final int ROTOR_II         = 1;    public static final int ROTOR_III        = 2;    public static final int ROTOR_IV         = 3;    public static final int ROTOR_V          = 4;    public static final int ROTOR_VI         = 5;    public static final int ROTOR_VII        = 6;    public static final int ROTOR_VIII       = 7;     public static final int ROTOR_BETA       = 8; // Thin rotor for M4    public static final int ROTOR_GAMMA      = 9; // Thin rotor for M4    public static final int REFLECTOR_A      =10;    public static final int REFLECTOR_B      =11;    public static final int REFLECTOR_C      =12;    public static final int REFLECTOR_B_THIN =13;    public static final int REFLECTOR_C_THIN =14;      public static final String [] ROTOR_MAPPING =  {        // 5 Standard Rotors for Wehrmacht Enigma        new String("EKMFLGDQVZNTOWYHXUSPAIBRCJ"), // ROTOR I        new String("AJDKSIRUXBLHWTMCQGZNPYFVOE"), // ROTOR II        new String("BDFHJLCPRTXVZNYEIWGAKMUSQO"), // ROTOR III        new String("ESOVPZJAYQUIRHXLNFTGKDCMWB"), // ROTOR IV        new String("VZBRGITYUPSDNHLXAWMJQOFECK"), // ROTOR V        new String("JPGVOUMFYQBENHZRDKASXLICTW"), // ROTOR VI        new String("NZJHGRCXMYSWBOUFAIVLPEKQDT"), // ROTOR VII        new String("FKQHTLXOCBJSPDZRAMEWNIUYGV"), // ROTOR VIII        new String("LEYJVCNIXWPBQMDRTAKZGFUHOS"), // ROTOR BETA        new String("FSOKANUERHMBTIYCWLQPZXVGJD"), // ROTOR GAMMA        // Last two mappings are for reflectors rather than rotors        new String("EJMZALYXVBWFCRQUONTSPIKHGD"),   // REFLECTOR A        new String("YRUHQSLDPXNGOKMIEBFZCWVJAT"),   // REFLECTOR B        new String("FVPJIAOYEDRZXWGCTKUQSBNMHL"),   // REFLECTOR C        new String("ENKQAUYWJICOPBLMDXZVFTHRGS"),   // REFLECTOR D (B THIN)        new String("RDOBJNTKVEHMLFCWZAXGYIPSUQ")    // REFLECTOR E (C THIN)     };     // Define the notch position on each rotor. Reflectors are static and have no notch.    // The notch is located on the alphabet ring and NOT on the core.    public static final char [][] NOTCH = {        {'Q','Q'}, {'E','E'}, {'V','V'}, {'J','J'}, {'Z','Z'}, // ROTORS I-V have only 1 notch        {'Z','M'}, {'Z','M'}, {'Z','M'},                       // ROTORS VI, VII, VIII have 2 notches        {'-','-'}, {'-','-'},                                  // ROTORS Beta & Gamma are static        {'-','-'}, {'-','-'}, {'-','-'}, {'-','-'}, {'-','-'}  // REFLECTORS are static};    };    public static final int  WHEELSIZE = 26;    public boolean notchEngaged = false;    protected char ringPosition = 0 ;    protected char startPosition = 0;    protected int [] mapForward = new int [WHEELSIZE] ;    protected int [] mapBackward = new int [WHEELSIZE] ;    protected char [] ring = new char [WHEELSIZE] ;    protected int whichRotor;    protected int idx = 0;    /** Create a new rotor by specifying the mapping forward through the ring, the ring position and        setting the rotor starting position.     */    public  rotor( char start, char ringPosition, int whichRotor ) {        if ( whichRotor > REFLECTOR_C_THIN || whichRotor <ROTOR_I ) {            System.out.println("Error - choose a rotor (0-4) or reflector (5-6)");            System.exit(1);        }        this.whichRotor = whichRotor;        reset (start, ringPosition );    }    /** Reset an existing rotor to it's original position. */    public void reset () {        reset ( startPosition, ringPosition  ) ;    }    /** Reset an existing rotor to a new starting position. */    public void reset ( char start, char ringPosition ) {        // Set up the ring position        this.ringPosition = Character.toUpperCase(ringPosition);          this.startPosition =  Character.toUpperCase(start);        // Rotate the ring to initial setting        ring = arrayUtils.rotate( new String("ABCDEFGHIJKLMNOPQRSTUVWXYZ").toCharArray(), 'A'-ringPosition);        // Initialize the rotor        for (int i = 0 ; i < WHEELSIZE ; i++ ) {            int  code = Character.toUpperCase(ROTOR_MAPPING[whichRotor].charAt(i)) - 'A';            mapForward[i] = (code+WHEELSIZE-i)%WHEELSIZE;            mapBackward[code] = (i+WHEELSIZE-code)%WHEELSIZE;        }        // Advance the rotors to new intial setting        advance( (startPosition+WHEELSIZE-ring[0])%WHEELSIZE ) ;        notchEngaged = ( (ring[this.idx] == NOTCH[whichRotor][0]) || (ring[this.idx] == NOTCH[whichRotor][1]) );   }    /** Advance the rotor a given number of positions and return true if the ring is over a notch at the end of the movement */    public boolean advance( int numOfTicks) {        this.idx = (this.idx + numOfTicks) % WHEELSIZE;        notchEngaged = ( (ring[this.idx] == NOTCH[whichRotor][0]) || (ring[this.idx] == NOTCH[whichRotor][1]) );        return notchEngaged;    }    public char indicatedPosition( ) {        return this.ring[this.idx];    }    public int passForward( int i ) {        return (mapForward[(i+this.idx) %WHEELSIZE]+i)%WHEELSIZE;    }    public int passBackward( int i ) {        return (mapBackward[(i+this.idx) % WHEELSIZE]+i)%WHEELSIZE;    }    /** Return information about the current state of the rotor */    public String toString() {        return ( new String( "Rotor ID: "+whichRotor + "  Ring Position: "+ringPosition + "   Indicated Position: "+new String(ring)));    }    public static void main( String[] args ) {        rotor r = new rotor( 'D', 'E', ROTOR_II );        System.out.println( r.toString() );        for (int i=0; i< WHEELSIZE ; i++ ) {            System.out.println( i + " (" + r.passForward(i) + ":" + r.passBackward(i) + ")");        }                }       }